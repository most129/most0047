from tkinter import *
from tkinter import ttk
import tkinter as tk, tkinter.ttk as ttk, os, shutil, paramiko, threading, eyed3, socket
from PIL import Image, ImageTk
from tkinter import filedialog as fd
from datetime import date
from winreg import *
from mutagen.mp3 import MP3
from mutagen.id3 import TIT2, TPE1, TPE2, TALB, TCON, TDRC, COMM, WXXX, TPUB, TRCK, TCOP
import tkinter.messagebox as mb
import py_win_keyboard_layout
import datetime, time
import sys
import tkinter as tk
from tkinter import messagebox
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.firefox.service import Service as FirefoxService
from selenium.webdriver.common.by import By
from selenium.webdriver import Firefox
from selenium.webdriver.firefox.options import Options
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import declarative_base, sessionmaker
from tkinter.scrolledtext import ScrolledText

# Раскладка клавиатуры
py_win_keyboard_layout.change_foreground_window_keyboard_layout(0x04090409)

tags = ["Еврейское мировоззрение", "http://toldot.com", "Толдот Йешурун", "Toldot Yeshurun, HaKisufim St 17, Jerusalem 9123101, Israel"]
lesson_genre = ["Талмуд", "Мировоззрение", "Еврейские законы", "Пиркей Авот", "Еврейская история", "ТАНАХ", "Еврейская семья", 
                "Недельная глава", "Еврейские праздники", "Рав Ицхак Зильбер", "Проблемы и вопросы", "Суббота", 
                "Тора и психология", "Вебинары", "Изучение иврита", "Женские уроки"]
lesson_genre_id = [1330, 1212, 1213, 1191, 1193, 1192, 1190, 1180, 1181, 1182, 1183, 1186, 1194, 1834, 1851, 785]

# Папка Загрузки
# path2 = r'C:\most129\\'
with OpenKey(HKEY_CURRENT_USER, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders') as key: Downloads = QueryValueEx(key, '{374DE290-123F-4565-9164-39C4925E467B}')[0]
path2 = Downloads + r'\\'

match socket.gethostname():
    case 'HONAN':
        path1 = r'D:\DATA5\Python\16869.ico'
        path3 = r'D:\DATA5\ZOOM\\'
        path4 = r'D:\DATA5\Python\\'
        profile_path = r'C:\Users\Хонан Либерман\AppData\Roaming\Mozilla\Firefox\Profiles\97qfydc7.default-release-1683630037344'
    case 'most129':
        path1 = r'E:\DATA2\Python\16869.ico'
        path3 = r'E:\DATA2\ZOOM\\'
        path4 = r'E:\DATA2\Python\\'
        profile_path = r'C:\Users\HONAN\AppData\Roaming\Mozilla\Firefox\Profiles\p9znfw8s.default'
    case _:
        mb.showerror("Не известный компьютер", socket.gethostname())
        sys.exit()

GeckoDriver_Firefox = False
driver = lesson_title = announcement = id_lesson_author = section_id = link = tags_for_publication = None

class App(tk.Tk):
    def __init__(self):
        # Начало главного окна
        
        super().__init__()
        
        self.canvas = Canvas(height = 1000, width = 1000)
        self.canvas.pack()
        self.test = PhotoImage(file='logo-ZOOM.png')
        self.testImg = self.canvas.create_image(780, 160, anchor = NW, image = self.test)
        
        self.title('Интегрированная среда создания аудио файлов ZOOM')
        self.geometry('1000x500+600+300')
        self.iconbitmap(path1)
        
        self.option_add("*tearOff", FALSE)
        self.debug_mode = False
        
        def edit_click_0001():
            messagebox.showinfo("ZOOM", "Нажата опция Создать")
            
        def edit_click_0002():
            sys.exit()
        
        def edit_click_0003():
            # Новая база данных
            
            # Создаем соединение с базой данных
            engine = create_engine('sqlite:///DATA.db')
                                   
            # Создаем класс-модель таблицы
            Base = declarative_base()
            class Author(Base):
                __tablename__ = 'authors'

                id = Column(Integer, primary_key=True)
                name = Column(String)
                prefix = Column(String)
                name_english = Column(String)
                id_author = Column(Integer)                  
            
            # Создаем таблицу в базе данных
            Base.metadata.create_all(engine)
            
            # Создаем объект сессии для работы с базой данных
            Session = sessionmaker(bind=engine)
            session = Session()
            
            # Добавляем новых пользователей в таблицу
            author1 = Author(name='Тамар Антопольски', prefix='', name_english='Tamar_Antopolsky', id_author=827)
            author2 = Author(name='Барух Бабаев', prefix='Р.', name_english='Baruch_Babaev', id_author=409)
            author3 = Author(name='Даниэль Бержанер', prefix='Р.', name_english='Daniel_Berzaner', id_author=306)
            author4 = Author(name='Хана Лея Бройтман', prefix='', name_english='Hannah_Leah_Broitman', id_author=887)
            session.add_all([author1, author2, author3, author4])
            session.commit()
            
            # Закрываем сессию
            session.close()
        
        def edit_click_0009():
            # Новое окно работы с базой данных
            
            def all_records():
                # Получаем все записи из таблицы и выводим их на экран
                text_widget.delete("1.0", tk.END)
                authors = self.session.query(Author).all()
                for author in authors:
                    text = f"{author.id}\t{author.prefix}\t{author.name}\t\t\t{author.name_english}\t\t\t{author.id_author}\n"
                    text_widget.insert(tk.END, text)
                    
            def delete_row():
                try:
                    selected_item = text_widget.get(tk.SEL_FIRST, tk.SEL_LAST)  # Получаем выделенный текст
                    values = selected_item.split('\t')  # Разделяем значения столбцов
        
                    if len(values) > 0:
                        id_value = int(values[0])  # Получаем значение идентификатора (первый столбец)
    
                        # Удаляем запись из базы данных по идентификатору
                        author = self.session.get(Author, id_value)
                        if author:
                            self.session.delete(author)
                            self.session.commit()
                            all_records()  # Обновляем вывод всех записей
                    else:
                        # Обработка ошибки при отсутствии выделенного текста или идентификатора
                        messagebox.showerror("Ошибка", "Некорректная строка для удаления.")
                except tk.TclError:
                    # Обработка ошибки при отсутствии выделенного текста
                    messagebox.showerror("Ошибка", "Необходимо выделить строку для удаления.")
                except ValueError:
                    # Обработка ошибки при некорректном идентификаторе
                    messagebox.showerror("Ошибка", "Необходимо выделить начало строки для удаления.")
    
            def add_row():
                # Функция для обработки добавления новой строки
                
                # Получаем значения из полей ввода
                name_value = name_entry.get()
                prefix_value = prefix_entry.get()
                name_english_value = name_english_entry.get()
                id_author_value = id_author_entry.get()
                
                # Создаем новый объект автора
                new_author = Author(name=name_value, prefix=prefix_value, name_english=name_english_value, id_author=id_author_value)

                # Добавляем новую строку в базу данных
                self.session.add(new_author)
                self.session.commit()
                all_records()
                
                # Очищаем поля ввода
                name_entry.delete(0, tk.END)
                prefix_entry.delete(0, tk.END)
                name_english_entry.delete(0, tk.END)
                id_author_entry.delete(0, tk.END)
                
            window_data = tk.Toplevel(app)
            window_data.title('Авторы публикаций')
            window_data.geometry('1000x500+630+270')
            window_data.iconbitmap(path1)
            window_data.focus_set()  # Сделать новое окно активным
    
            # Создаем виджет ScrolledText для вывода информации
            text_widget = ScrolledText(window_data, width=70, height=29)
            text_widget.place(x=10, y=10)  # Устанавливаем положение виджета
            
            # Получаем все записи из таблицы и выводим их на экран
            all_records()
            
            # Создаем поля ввода для добавления новых строк
            name_label = tk.Label(window_data, text="Имя")
            name_label.place(x=600, y=10)            
            name_entry = tk.Entry(window_data, width=47)
            name_entry.place(x=704, y=10)
    
            name_label = tk.Label(window_data, text="Префикс")
            name_label.place(x=600, y=40)
            prefix_entry = tk.Entry(window_data, width=5)
            prefix_entry.place(x=704, y=40)
    
            name_label = tk.Label(window_data, text="Name")
            name_label.place(x=600, y=70)
            name_english_entry = tk.Entry(window_data, width=47)
            name_english_entry.place(x=704, y=70)
    
            name_label = tk.Label(window_data, text="ID")
            name_label.place(x=600, y=100)
            id_author_entry = tk.Entry(window_data, width=5)
            id_author_entry.place(x=704, y=100)
                
            # Создаем кнопку для добавления новой строки
            add_button = tk.Button(window_data, text="Добавить", command=add_row)
            add_button.place(x=600, y=130)
            
            # Удалить строку
            delete_button = tk.Button(window_data, text="Удалить строку", command=delete_row)
            delete_button.place(x=600, y=160)
       
        def edit_click_0004():
            if self.debug_mode:
                self.label_0001.destroy()
                self.debug_mode = False
            
        def edit_click_0005():
            self.label_0001 = self.label = tk.Label(self, text="Режим отладки", background = 'YellowGreen')
            self.label_0001.place(relx=.05, rely=.008)
            self.debug_mode = True
            
        def edit_click_0006():
            self.remove_labels()
        
        def edit_click_0007():
            # Публикация материала
            
            global GeckoDriver_Firefox, driver, lesson_title, announcement, id_lesson_author, section_id, link, tags_for_publication
            
            if not GeckoDriver_Firefox:
                options = Options()
                options.add_argument("-profile")
                options.add_argument(profile_path)
                service = FirefoxService(GeckoDriverManager().install())
                driver = Firefox(service=service, options=options)
                GeckoDriver_Firefox = True

            # Определение текущего количества открытых вкладок
            initial_handles = driver.window_handles

            # Открытие новой вкладки
            driver.execute_script("window.open('about:blank');")

            # Переключение на следующую вкладку
            driver.switch_to.window(driver.window_handles[len(initial_handles)])

            driver.get("https://toldot.com/netcat/admin/#object.add(369)")

            time.sleep(1)
            frame = driver.find_element(By.NAME, "mainViewIframe")
            driver.switch_to.frame(frame)
            time.sleep(1)

            summary = driver.find_element(By.NAME, "f_Title_rus")
            summary.send_keys(lesson_title)
            summary = driver.find_element(By.NAME, "f_Summary_short")
            summary.send_keys(announcement)
            summary = driver.find_element(By.NAME, "Authstr")
            summary.send_keys(id_lesson_author)
            summary = driver.find_element(By.NAME, "Secstr")
            summary.send_keys(section_id)
            # summary = driver.find_element(By.NAME, "Cicle_IDstr")
            # summary.send_keys("874")
            summary = driver.find_element(By.NAME, "f_File_audio")
            summary.send_keys(link)
            
            button = driver.find_element(By.XPATH, '//span[contains(@onclick, "GetTime")][contains(@onclick, "f_File_audio")][contains(@onclick, "audio")][contains(@onclick, "getFileSize")]')
            button.click()
            
            now = datetime.datetime.now()
            
            summary = driver.find_element(By.NAME, "f_Date_day")
            summary.send_keys(now.strftime("%d"))
            summary = driver.find_element(By.NAME, "f_Date_month")
            summary.send_keys(now.strftime("%m"))
            summary = driver.find_element(By.NAME, "f_Date_year")
            summary.send_keys(now.strftime("%Y"))
            summary = driver.find_element(By.NAME, "f_Date_hours")
            summary.send_keys(now.strftime("%H"))
            summary = driver.find_element(By.NAME, "f_Date_minutes")
            summary.send_keys(now.strftime("%M"))
            summary = driver.find_element(By.NAME, "f_Keywords")
            summary.send_keys("Аудио")
            summary = driver.find_element(By.NAME, "f_Tags")
            summary.send_keys(tags_for_publication)

            driver.switch_to.default_content()

            # button = driver.find_element(By.XPATH, '//td[@class="bottom_button_body"][text()="Добавить"]')
            # button.click()
            # driver.close()

        def edit_click_0008():
            # Определение имени автора
            print()
            
        main_menu = Menu()
        
        file_menu_01 = Menu()
        file_menu_01.add_command(label="Создать", command=edit_click_0001)
        file_menu_01.add_command(label="Открыть")
        file_menu_01.add_command(label="Сохранить как...")
        file_menu_01.add_command(label="Опубликовать материал", command=edit_click_0007)
        file_menu_01.add_separator()
        file_menu_01.add_command(label="Выход", command=edit_click_0002)
        
        file_menu_02 = Menu()
        file_menu_02.add_command(label="База данных DATA", command=edit_click_0003)
        file_menu_02.add_command(label="Определить автора", command=edit_click_0008)
        file_menu_02.add_command(label="Рабочий режим", command=edit_click_0004)
        file_menu_02.add_command(label="Режим отладки", command=edit_click_0005)
        
        # Проверяем наличие файла DATA.db
        if os.path.isfile('DATA.db'):
            file_menu_02.entryconfigure(0, state=tk.DISABLED)
        
        file_menu_03 = Menu()
        file_menu_03.add_command(label="Авторы публикаций", command=edit_click_0009)
        
        main_menu.add_cascade(label="Файл", menu=file_menu_01)
        main_menu.add_cascade(label="Редактирование", menu=file_menu_03)
        main_menu.add_cascade(label="Параметры", menu=file_menu_02)
 
        self.config(menu=main_menu)
        
        # Продолжение главного окна
        
        # Создаем соединение с базой данных
        engine = create_engine('sqlite:///DATA.db')
            
        # Создаем класс-модель таблицы
        Base = declarative_base()
        class Author(Base):
            __tablename__ = 'authors'

            id = Column(Integer, primary_key=True, autoincrement=True)
            name = Column(String)
            prefix = Column(String)
            name_english = Column(String)
            id_author = Column(Integer)
            
        # Создаем объект сессии для работы с базой данных
        Session = sessionmaker(bind=engine)
        self.session = Session()
        
        # Устанавливаем обработчик события закрытия окна
        self.protocol("WM_DELETE_WINDOW", self.close_window)
        
        # Предварительные действия        
        self.run_action_0001()
        
    def close_window(self):
        # Обработчик события закрытия окна
            # Закрываем сессию при закрытии окна
            self.session.close()
            self.destroy()
        
    def remove_labels(self):
        destroy_object = [self.label_0002, self.label_0003, self.label_0004, self.label_0005]
        for object_name in destroy_object:
            object_name.destroy()
        
    def run_action_0001(self):
        self.image_0001 = True
        # Проверить папку Загрузки
        self.files = os.listdir(path2)
        for i in self.files:
            self.file_name = i
            self.exist = "GMT" in self.file_name
        if self.exist:
            self.file = i
        else:
            self.file = 'Директория пуста'
        
        # Имя файла в директории «Загрузки»
        self.most2 = r'Имя файла в директории «Загрузки» — ' + self.file
        self.label_0002 = tk.Label(self, text=self.most2)
        self.label_0002.place(relx=.05, rely=.05)
        
        self.button = tk.Button(self, command=self.start_action_1, text="Проверить файлы на сервере")
        self.button.place(relx=.708, rely=.05 - .005)
        
    def start_action_1(self):
        self.button.config(state=tk.DISABLED)
        thread = threading.Thread(target=self.run_action_0002)
        thread.start()
        self.check_thread(thread)
    
    def start_action_2(self):
        self.button.config(state=tk.DISABLED)
        thread = threading.Thread(target=self.run_action_0007)
        thread.start()
        self.check_thread(thread)

    def check_thread(self, thread):
        if thread.is_alive():
            self.after(100, lambda: self.check_thread(thread))
        else:
            self.button.config(state=tk.NORMAL)

    def run_action_0002(self):
        # Прогрессбар 1
        self.label_0006 = tk.Label(self, text='Соединение с сервером', foreground="blue")
        self.label_0006.place(relx=.505, rely=.10)
        
        self.progress_bar = ttk.Progressbar(self, length=150, orient="horizontal", mode="determinate", maximum=100, value=0)
        self.progress_bar.place(relx=.5, rely=.05)
        self.progress_bar.start()
        self.progress_bar.step(10)
        
        # Соединение с сервером
        self.host = '176.9.18.7'
        self.user = 'hliberman'
        self.secret = '*********'
        self.port = 38653
        
        self.ssh = paramiko.SSHClient()
        self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.ssh.connect(hostname=self.host, username=self.user, password=self.secret, port=self.port)
        self.ftp=self.ssh.open_sftp()
        
        self.ftp.chdir("/media.toldot.ru/ZOOM/")            # перейти в директорию
        self.currentDir = self.ftp.getcwd()                 # получить директрию где находишся
        self.fileList=self.ftp.listdir();                   # выводит и фалы и папки одним общим списком
        # self.ssh.close()
        
        self.fileList.sort()
        self.x = self.fileList [-1]
        self.y = self.x[:4]
        self.z = int(self.y) + 1
        self.w = str(self.z)
        self.file2 = self.w + '_источник' + '.mp4'
        
        # Имя файла на сервере
        self.progress_bar.stop()
        
        self.label_0006.destroy()
        self.progress_bar.destroy()
        
        self.most1 = r'Имя файла на сервере media.toldot.ru/ZOOM/ — ' + self.x
        self.label_0003 = tk.Label(self, text=self.most1)
        self.label_0003.place(relx=.05, rely=.10)
       
        # Имя в директории F:\DATA2\Python
        if self.file != 'Директория пуста':
            self.most2 = r'Имя файла в директории F:\DATA2\Python — ' + self.file2
            self.label_0004 = tk.Label(self, text=self.most2)
            self.label_0004.place(relx=.05, rely=.15)
            if self.debug_mode:                             # Вхождение 1  
                shutil.copy(path2 + r'\\' + self.file, path4 + self.file2)  
            else:
                shutil.move(path2 + r'\\' + self.file, path4 + self.file2)
            
        self.button = tk.Button(self, command=self.run_action_0003, text="Сформирован файл mp3")
        self.button.place(relx=.708, rely=.15)

    def run_action_0003(self):
        # Тегирование
        self.label = tk.Label(self, text="Тегирование")
        self.label.place(relx=.05, rely=.20)
        
        self.imname = path4 + "A001 ZOOM конференция.jpg"
        self.im1 = Image.open(self.imname)
        self.size = (300, 300)
        self.im2 = ImageTk.PhotoImage(Image.open(self.imname).resize(self.size))

        self.button = tk.Button(self, image=self.im2, command=self.run_action_0004, relief = 'flat')
        self.button.place(relx=.05, rely=.25)

    # Картинка
    def run_action_0004(self):
        self.imname= fd.askopenfilename()
        self.im1 = Image.open(self.imname)
        self.size = (300, 300)
        self.im2 = ImageTk.PhotoImage(Image.open(self.imname).resize(self.size))
        
        # mp3
        # self.file2 = '2738_источник.mp4' # Это чтобы не проверять сервер
        self.file2 = self.file2.replace("mp4", "mp3")
        
        # Тег картинка
        audiofile = eyed3.load(self.file2)
        audiofile.tag.images.set(3, open(self.imname,'rb').read(), 'image/jpeg')
        audiofile.tag.save()
        
        self.button = tk.Button(self, image=self.im2, command=self.run_action_0004, relief = 'flat')
        self.button.place(relx=.05, rely=.25)
        
        # Если нажали на картинку первый раз
        if self.image_0001:
            self.run_action_0005()
        else:
            self.run_action_0010()
            
    # Поля ввода тегов
    def run_action_0005(self):
        self.image_0001 = False
        self.fields = ["Урок №", "Тема", "Автор", "Цикл", "Жанр", "Год", "Анонс", "Ссылка", "Авторские права", "Издатель", "Name"]
        self.labels = [tk.Label(self, text=f) for f in self.fields]
        self.entries = [tk.Entry(self) for _ in self.fields]
        self.widgets = list(zip(self.labels, self.entries))

        # Заполнение таблицы тегов
        for i, (label, entry) in enumerate(self.widgets):
            match i:
                case 0:
                    label.place(relx=.708, rely=.25+i*0.05)
                    entry.place(width = 30, relx=.70, rely=.25+i*0.05, anchor="ne")
                case 4:
                    entry.insert(0, tags[0])
                    label.place(relx=.708, rely=.25+i*0.05)
                    self.label.place(relx=.70, rely=.25+i*0.05, anchor="ne")
                    self.combobox_01 = ttk.Combobox(height = 20, values=lesson_genre)
                    self.combobox_01.place(relx=.70, rely=.25+i*0.05, anchor="ne")
                case 5:
                    self.today = date.today()
                    entry.insert(0, self.today.year)
                    label.place(relx=.708, rely=.25+i*0.05)
                    self.label = tk.Label(self, text=self.today.year, background = 'Beige')
                    self.label.place(relx=.70, rely=.25+i*0.05, anchor="ne")
                case 7:
                    entry.insert(0, tags[1])
                    label.place(relx=.708, rely=.25+i*0.05)
                    self.label = tk.Label(self, text=tags[1], background = 'Beige')
                    self.label.place(relx=.70, rely=.25+i*0.05, anchor="ne")
                case 8:
                    entry.insert(0, tags[2])
                    label.place(relx=.708, rely=.25+i*0.05)
                    self.label = tk.Label(self, text=tags[2], background = 'Beige')
                    self.label.place(relx=.70, rely=.25+i*0.05, anchor="ne")
                case 9:
                    entry.insert(0, tags[3])
                    label.place(relx=.708, rely=.25+i*0.05)
                    self.label = tk.Label(self, text=tags[3], background = 'Beige')
                    self.label.place(relx=.70, rely=.25+i*0.05, anchor="ne")
                case 10:
                    #label.place(relx=.708, rely=.25+i*0.05)
                    #entry.place(width = 120, relx=.70, rely=.25+i*0.05, anchor="ne")
                    print
                case _:
                    label.place(relx=.708, rely=.25+i*0.05)
                    entry.place(width = 330, relx=.70, rely=.25+i*0.05, anchor="ne")
                    
        self.run_action_0010()
    
    def run_action_0010(self):
        self.button = tk.Button(self, command=self.run_action_0006, text="Записать файл на сервер")
        self.button.place(relx=.708, rely=.80)
    
    def run_action_0006(self):
        global lesson_title, announcement, id_lesson_author, section_id, lesson_genre, lesson_genre_id, tags_for_publication
        
        audio_file = MP3(self.file2)
        
        # Создаем соединение с базой данных
        engine = create_engine('sqlite:///DATA.db')

        # Создаем базовую модель для объявления класса-модели таблицы
        Base = declarative_base()

        # Определяем класс-модель таблицы
        class Author(Base):
            __tablename__ = 'authors'

            id = Column(Integer, primary_key=True, autoincrement=True)
            name = Column(String)
            prefix = Column(String)
            name_english = Column(String)
            id_author = Column(Integer)

        # Создаем объект сессии для работы с базой данных
        Session = sessionmaker(bind=engine)
        session = Session()
        
        # Список префиксов для отбрасывания
        prefixes_to_discard = ["Р. ", "Др. ", "Рав ", "Рабанит "]
        
        for self.label, self.entry in self.widgets:
            match self.label.cget("text"):
                case "Урок №":
                    audio_file["TRCK"] = TRCK(encoding=3, text=self.entry.get())
                case "Тема":
                    lesson_title = self.entry.get()
                    audio_file["TIT2"] = TIT2(encoding=3, text=lesson_title)
                case "Автор":
                    name_input = self.entry.get()
                    audio_file["TPE1"] = TPE1(encoding=3, text=name_input)
                    audio_file["TPE2"] = TPE2(encoding=3, text=name_input)
                case "Цикл":
                    audio_file["TALB"] = TALB(encoding=3, text=self.entry.get())
                case "Жанр":
                    section=self.combobox_01.get()
                    index = lesson_genre.index(section)  # Получение индекса элемента
                    section_id = lesson_genre_id[index]  # Получение соответствующего элемента из списка lesson_genre_id
                    audio_file["TCON"] = TCON(encoding=3, text=section)
                case "Год":
                    audio_file["TDRC"] = TDRC(encoding=3, text=date.today().strftime("%Y"))
                case "Анонс":
                    announcement = self.entry.get()
                    audio_file["COMM"] = COMM(encoding=3, desc='', text=announcement)
                case "Ссылка":
                    audio_file["WXXX"] = WXXX(encoding=3, url=r"http://toldot.com")
                case "Авторские права":
                    audio_file["TCOP"] = TCOP(encoding=3, text="Толдот Йешурун")
                case "Издатель":
                    audio_file["TPUB"] = TPUB(encoding=3, text="Toldot Yeshurun, HaKisufim St 17, Jerusalem 9123101, Israel")
                #case "Name":
                #    self.Name = self.entry.get()
                
        # Проверяем наличие префиксов в начале name_input и отбрасываем их
        for prefix in prefixes_to_discard:
            if name_input.startswith(prefix):
                name_input = name_input[len(prefix):]
        
        tags_for_publication = name_input + "," + "Zoom-конференция,"
        
        # Ищем элемент с заданным name в базе данных
        self.Name = session.query(Author).filter_by(name=name_input).first()
        
        author = session.query(Author).filter(Author.name == name_input).first()
        id_lesson_author = author.id_author
        
        audio_file.save()
        
        self.x = self.file2[:5]
        self.file3 = self.x + self.Name.name_english + '.mp3'
        
        if self.debug_mode:                         # Вхождение 2
            shutil.copyfile(self.file2, self.file3)
        else:
            os.rename(self.file2, self.file3)

        self.start_action_2()
        
    def run_action_0007(self):
        # Прогрессбар 2
        global link
        
        self.label_0007 = tk.Label(self, text='Запись файла на сервер', foreground="blue")
        self.label_0007.place(relx=.505, rely=.10)
        self.progress_bar = ttk.Progressbar(self, length=150, orient="horizontal", mode="determinate", maximum=100, value=0)
        self.progress_bar.place(relx=.5, rely=.05)
        self.progress_bar.start()
        self.progress_bar.step(10)
        
        # Этот блок под вопросом
        self.currentDir = self.ftp.getcwd()                   # получить директрию где находишся
        # self.fileList=self.ftp.listdir();                   # выводит и фалы и папки одним общим списком
        self.file4 = r"/media.toldot.ru/ZOOM/" + self.file3
        
        if not self.debug_mode:                         # Вхождение 3
            self.ftp.put(self.file3, self.file4)
        
        self.ssh.close()
        
        self.progress_bar.stop()
        
        self.label_0007.destroy()
        self.progress_bar.destroy()
        
        self.file4 = r'https:/' + self.file4
        # Замена на com
        self.file4 = self.file4.replace("ru", "com")
        link = self.file4
        self.label_0005 = tk.Label(self, text=link, background = 'BlanchedAlmond')
        self.label_0005.place(relx=.70, rely=.90, anchor="ne")
        
        self.button = tk.Button(self, command=self.run_action_0008, text="Копировать ссылку")
        self.button.place(relx=.708, rely=.90 - .005)
        
        self.button = tk.Button(self, command=self.run_action_0009, text="Следующий файл")
        self.button.place(relx=.84, rely=.90 - .005)
        
    def run_action_0009(self):
        self.remove_labels()
        # Предварительные действия        
        self.run_action_0001()
        # Активация первой кнопки
        self.button.config(state=tk.NORMAL)
    
    def run_action_0008(self):
        tk = Tk()
        tk.withdraw()
        tk.clipboard_clear()
        tk.clipboard_append(self.file4)
        tk.update()
        tk.destroy()
        
app = App()
app.mainloop()
